[[{"l":"The Lazy TypeScript Guidelines","p":["The Lazy TypeScript Guidelines is a set of guidelines for writing code that is easy to understand, easy to maintain, and at the same time minimizing the amount of decisions you take while writing."]},{"i":"why-minimize-decisions","l":"Why minimize decisions?","p":["Decisions are hard, sometimes take a lot of time, can lead to long discussions in code reviews and can be a source of bugs.","This guide offers a set of decisions that you and your team can follow to focus on what really matters, writing good code."]},{"i":"how-did-this-guide-come-to-be","l":"How did this guide come to be?","p":["This guide is the result of about a year of experience in front-end and Node.js development. The author is very interested in TypeScript's type system, Node.js, and React's data flow. One year is clearly not enough experience, so this guide is a living document that will be updated as the author learns more."]}],[{"l":"Naming convention","p":["Here lies the default naming convention for JavaScript code. The guide may define additional rules for specific contexts. To see more, find the Naming convention sections of other categories."]},{"l":"Variables","p":["Variables should be in camelCase.","ALL_CAPS is allowed for constants, but the guide has no specific definition of what is considered a constant.","This is an incomplete section that still needs work, because it doesn't provide a clear definition of what is considered a constant."]},{"l":"Functions and methods","p":["Both functions and methods should be in camelCase."]},{"l":"Classes","p":["Classes should be in PascalCase."]},{"l":"Statement labels","p":["Statement labels should be in camelCase."]}],[{"l":"Avoid default exports","p":["Default exports should always be avoided.","Default exports make it harder to batch rename exported values, and allows for accidentally importing a value with a different name than expected.","Default exports also create an additional source of decisions when importing a module, and they don't provide any concrete benefit over named exports.","This guide will not repeat what other style guides already say, instead, you can read them for yourself and come to your own conclusions.","Google TypeScript Style Guide TypeScript Deep Dive"]}],[{"l":"Expressions"},{"l":"Use strict equality","p":["Always use the ===(strict equality) and !==(strict inequality) operators to compare two values. Using the same approach for all comparisons will make your code more consistent and gives you one less thing to think about."]},{"l":"ESLint Rule","p":["ESLint's eqeqeq rule should be enabled to enforce this. It also has a\"smart\" option that allows == in certain conditions, and I often used it in the past. However, using the default setting gives you more consistency and will help everyone avoid non-productive discussions in code reviews.","Expressions"]},{"i":"prefer-postfix-decrementincrement","l":"Prefer postfix decrement/increment","p":["When incrementing or decrementing a variable, use the prefix notation (++i) unless the context requires the postfix notation ( i++). The prefix notation is more clear because the result of the expression has the same value as i after evaluation, while in postfix notation the resulting value is outdated compared to the new value of i.","Here we don't need to defer the update to i, so the prefix notation is simpler.","Now, here's an example where the postfix notation is necessary:","This is a bad example because we have no reason to use the postfix notation, since deferring the update to i is not necessary.","Now, here's an example where the prefix notation causes a problem:"]},{"l":"Avoid the comma operator","p":["The comma operator allows you to evaluate a sequence of expressions as a single expression, which results in the value of the last expression. This is a confusing form of operation sequencing and should be avoided."]},{"l":"Avoid function expressions","p":["Arrow functions should be favored over function expressions. Arrow functions are terser and more predictable in regards to the this keyword.","Function expression was used when not necessary. This is incorrect.","When you need a dynamically bound this, function expressions may be necessary and are therefore allowed."]},{"l":"Avoid implicit coercion","p":["Some ways to convert values to another type are obscure and should be avoided, here are some bad examples:"]},{"l":"ESLint Rule","p":["The no-implicit-coercion ESLint rule can be enabled to enforce this.","Expressions"]},{"l":"Avoid other types when booleans are expected","p":["In contexts where a boolean value is expected, such as an if condition, avoid passing non-boolean values directly. Instead, explicitly compare the value to something in order to make the intent clear.","Contexts in which this rule applies include conditions for if, while, for, and do-while statements. It also applies for the operands of the logical negation ! operator, binary logical operators and ||, and the first operand for the conditional (ternary) operator.","ESLint Rule","The strict-boolean-expressions ESLint rule can be enabled to enforce this.","Expressions","Use the nullish coalescing operator (??) instead of the logical OR operator(||) when you want a fallback value for when an expression is null or undefined.","When you really want to check for falsy values, you may freely use the logical OR operator."]},{"l":"ESLint Rule","p":["The prefer-nullish-coalescing ESLint rule can be enabled to enforce this.","Expressions"]}],[{"l":"Functions"},{"l":"Always use objects as parameters","p":["Functions that have parameters should always have a single (object) parameter instead of multiple parameters, this makes refactoring easier and makes it easier to know what each argument is at a glance.","This invocation makes it clear that we are inserting the value foo at index 2 and we are inserting it 3 times.","This invocation is less clear about what each argument is, requiring the reader to see the function definition or enable inlay hints."]}],[{"l":"Import order","p":["Imports should be sorted in a consistent order, with third-party modules first, followed by modules from your organization, then custom path aliases set up in your project, and finally local imports."]},{"l":"Prettier plugin","p":["The recommended way for automatically sorting imports is through a Prettier plugin named prettier-plugin-sort-imports.","A recommended configuration is something like:","Import order"]}],[{"l":"Iterators"},{"l":"Avoid .forEach","p":["Avoid using .forEach when you can use the for...of statement.","for...of can be faster, more consistent across different iterables, allows you to use break, continue, and return, and works better with type narrowing.","You can use eslint-plugin-unicorn's no-array-for-each ESLint rule to detect and fix .forEach calls.","no-array-for-each"]}],[{"l":"Variables"},{"l":"Use const by default","p":["Variables should be declared with const by default. let should only be used when a variable needs to be reassigned."]},{"l":"Never use var","p":["var has confusing scoping rules and should never be used."]}],[{"l":"Naming convention","p":["Here lies the default naming convention for TypeScript code. The guide may define additional rules for specific contexts. To see more, find the Naming convention sections of other categories."]},{"l":"Enums","p":["Enums should be in PascalCase and named in singular form. Enum members should be in ALL_CAPS.","Enum values have no specific convention.","This is bad because the enum name is not in singular form, and the enum members are not in ALL_CAPS."]},{"l":"ESLint Rule","p":["The @typescript-eslint/naming-convention ESLint rule can be used to enforce this.","Naming convention"]}],[{"l":"Defining types"},{"l":"Variants","p":["Enums should be used when declaring variants based on a fixed set of values.","Here the enum constants are implementation details.","Enums can be replaced by arrays or objects with const assertions, which are straightforward and don't introduce as many abstractions and implementation details as enums do, but they are less type-safe because the type checking is based on the values themselves rather than which enum was used. Enums have type checking even if the underlying constant is the same.","Let's see an example enum and two ways of replacing it.","Original enum:","Resulting type:"]},{"l":"Type parameters","p":["Generic type parameters should be prefixed by T and should be in PascalCase.","Good names include TName, TFunctionMap, TRootState.","Bad names include Name(not prefixed by T), and TfunctionMap( functionMap not in PascalCase)."]},{"l":"ESLint Rule","p":["This can be enforced using the @typescript-eslint/naming-convention ESLint rule.","naming-convention"]},{"l":"Properties with function types"},{"l":"Avoid arrow function syntax","p":["Properties with function type declarations should not use the arrow function syntax."]},{"l":"Function parameters","p":["Functions that take a single object parameter (which are encouraged by this guide) should define a type for that object. That type should have the name of the function in PascalCase with pre Props suffix."]},{"l":"Avoid inline types for destructured parameters","p":["Functions taking more than one parameter are discouraged, but if used, inline types are allowed when they are simple enough:","Simple types are primitive types, like string, number, boolean, generic types, such as ArrayT and Recordstring, number, and interfaces, classes and type aliases.","Union types, intersection types and custom object types should be used through type aliases."]}],[{"l":"Discoverability","p":["Discoverability across a codebase refers to how easy it is to locate specific functionalities."]},{"l":"What is greppability","p":["One metric related to discoverability is greppability. Greppability is a measure of how easy it is to find something in a codebase using textual search. The linked article below explains this concept in detail.","Greppability is an underrated code metric"]},{"l":"Greppability in file names","p":["One place where greppability is important is in the naming of files. In Visual Studio Code and I assume other editors, it's possible to navigate to a specific file via the CTRL+P command.","If you have an application that has many dashboards, it's likely that they'll define components with similar names and functions. For example, assume each dashboard defines components named Filter and Results. You should specify which dashboard each component is related to, like CodeMetricsFilter and CodeMetricsResults. This way, you can easily differentiate their editor tabs from other tabs, and also find them quickly via keyboard shortcuts."]},{"l":"Discoverability for React","p":["React applications are mostly dominated by React concepts such as components, hooks, and context. Each should be easily identifiable in the codebase."]},{"l":"Components","p":["Our component file naming conventions allows components to be quickly identified across the codebase. View the page below for more information.","Discoverability"]},{"l":"Hooks","p":["Files that export hooks should be named like the hook, including the use- prefix. This way, you can easily identify hooks."]},{"l":"Contexts","p":["This is an incomplete section that still needs work."]}],[{"l":"JSDoc","p":["JSDoc is a standard for documenting JavaScript code, often associating comments with functions, classes, types and variables."]},{"l":"Ensure consistency","p":["To reduce decisions and ensure consistency, it's recommended to use a tool like eslint-plugin-jsdoc."]},{"l":"Recommended base rules","p":["Here's a complete eslint-plugin-jsdoc ruleset that treats plain incorrect JSDoc as errors and warns about stylistic choices:"]}],[{"l":"Naming convention","p":["Here lies the default naming convention for React code."]},{"l":"Components","p":["Variables should be in PascalCase."]},{"l":"Contexts","p":["Contexts should be in PascalCase.","This is an incomplete section that still needs work. It doesn't specify whether contexts should be suffixed with Context or not."]},{"l":"setState callback parameter","p":["The parameter of a callback provided to setState callback should be named v.","In case the identifier v is already used, you should use the initials of the state variable name. This means a state variable named dogsCount should mean a callback parameter named dc."]},{"l":"Rationale","p":["Using arbitrary parameter names like selectedIds can lead to the name getting out of sync when the actual state variable is renamed. This can cause confusion.","Using v or the initials of the state variable name ensures that the parameter is never outdated, and becomes natural and quick to read after some time.","Using a descriptive name is also redundant because the state setter function already has a name that describes the parameter.","In the exceedingly rare case where the identifier v is already used in a state setter, we use the initials just to not be totally arbitrary."]},{"l":"Event handlers","p":["Event handlers should be in PascalCase and be prefixed with handle.","This guide doesn't consider an event handler only native browser events like click or submit, but also any callbacks that are expected to react to some event from a child component.","In this example, handleClear is an event handler that reacts to an action from ClearCart. It correctly follows the name convention.","There's nothing inherently wrong with the code above, but it doesn't follow the convention of prefixing event handlers with handle."]},{"l":"Props that receive event handlers","p":["Props that receive event handlers should be in PascalCase and be prefixed with on."]}],[{"l":"Components"},{"l":"One component per file","p":["Components should be defined in a file dedicated to them, which exports nothing else and is named like the component.","The official React docs refer to components as \"reusable UI elements for your app\". Having the components in their own files make them more self-contained and navigable.","Here the file name matches the component exactly.","Here the file name has incorrect casing.","Components: UI building blocks"]},{"l":"Defining prop types","p":["Define prop types for components using either type or interface, I don't think there's much value to be gaining in standardizing which keyword to use as interfaces seem to have better compile performance than intersection types, but don't allow for more precise type definitions. Declaration merging should not be common for most component props, so it's not an important factor.","The type should be named Props and be exported, allowing reuse for type checking in other modules.","In the above cases the type name is correct and it is properly exported.","In the above cases the type name is either not exported or named incorrectly( Prop)."]}],[{"l":"JSX Prop order","p":["In JSX, props should be passed in a consistent order. This makes scanning for specific props faster, and ensures consistent writing and resolution of conflicts.","react/jsx-sort-props"]},{"l":"ESLint Rule","p":["I suggest using the eslint-plugin-react rule react/jsx-sort-props. Feel free to choose the order that makes the most sense to you and your team."]},{"l":"Personal preference","p":["I prefer to order props in ascending alphabetical order, with className, ref and style first and with callbacks last, for example:"]},{"l":"Rationale","p":["I order props in this way because it makes sense to me. They are closely relatd to this way of subjectively splitting them, while still being objective:","Meta: Props that aren't specific to the component, instead being standard like className, ref, and style.","What it displays: Props that define the component's appearance or what it displays.","How it behaves: Props that define how the component behaves, like callbacks.","This logic separation is obviously subjective and impossible to enforce consistently, so the ESLint rule is very encouraged to avoid conflicts while still resembling this separation."]}],[{"l":"Memoization"},{"l":"When to use useCallback","p":["useCallback returns a memoized version of a callback function that only changes if one of the dependencies has changed. This makes it useful to avoid re-renders of child components and recalculations that depend on the callback every time the parent component renders."]},{"l":"Callbacks that are passed to child components","p":["When you pass a callback to a child component, you should wrap it in useCallback because it may prevent unnecessary re-renders of the child component and recalculations inside that component.","In this example, increment and decrement are wrapped in useCallback because Controls may be wrapped in React.memo, or have effects or memoization hooks that have the callback in their dependency array, which present recalculations that can be avoided by memoizing the callbacks.","The code above is bad because Controls will re-render every time Counter is rendered, and hook in Controls that depends on increment or decrement will recalculate every time as they are different functions every time."]},{"l":"Callbacks that are passed to dependency arrays","p":["When you pass a callback to a dependency array of a hook, you should wrap it in useCallback to avoid unnecessary effect executions and recalculations.","The code above allows the ProductProvider to rerender as many times as it needs without causing recalculations in components that depend on the ProductContext, because favoriteProduct is memoized with useCallback and value is memoized with useMemo.","If favoriteProduct was not memoized with useCallback, it would be a different function every time ProductProvider rerenders, causing value to be a different object every time.","The provider above is bad because every component that depends on ProductContext will rerender or do recalculations every time ProductProvider rerenders, as even though value is memoized with useMemo, favoriteProduct is a different function every time."]},{"l":"When to avoid useCallback","p":["Avoid useCallback when the callback is not used in any dependency array, and is only used in native components such as an a or button. Native tags don't have possibly complex logic that can be avoided by memoizing the callback."]}]]